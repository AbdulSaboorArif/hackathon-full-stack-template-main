# Data Model: Authentication System

**Feature**: Multi-User Authentication System
**Branch**: `001-user-auth`
**Date**: 2025-12-17
**Status**: Complete

## Overview

This document defines the database schema for the authentication system. The data model enforces user isolation through foreign key relationships and ensures all user-scoped data is properly associated with authenticated users.

## Entity Relationship Diagram

```
┌─────────────────────┐
│      Users          │
│─────────────────────│
│ id (PK)             │ TEXT (UUID)
│ email (UNIQUE)      │ TEXT
│ name                │ TEXT
│ password_hash       │ TEXT
│ created_at          │ TIMESTAMP
│ updated_at          │ TIMESTAMP
└─────────────────────┘
          │
          │ 1:N
          │
          ▼
┌─────────────────────┐
│      Tasks          │
│─────────────────────│
│ id (PK)             │ INTEGER
│ user_id (FK)        │ TEXT → users.id
│ title               │ TEXT
│ description         │ TEXT (nullable)
│ completed           │ BOOLEAN
│ created_at          │ TIMESTAMP
│ updated_at          │ TIMESTAMP
└─────────────────────┘
```

## Entities

### User Entity

**Purpose**: Stores user authentication credentials and serves as the ownership identifier for all user-scoped data.

**Managed By**: Better Auth (frontend library automatically creates and manages this table)

**Schema**:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | TEXT | PRIMARY KEY | UUID v4 generated by Better Auth |
| `email` | TEXT | UNIQUE, NOT NULL | User's email address (RFC 5322 format) |
| `name` | TEXT | NOT NULL | User's display name (1-100 characters) |
| `password_hash` | TEXT | NOT NULL | bcrypt hashed password (managed by Better Auth) |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Account creation timestamp |
| `updated_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last account update timestamp |

**Indexes**:
- Primary key index on `id` (automatic)
- Unique index on `email` (Better Auth creates this)

**Validation Rules**:
- **Email**: Must be valid RFC 5322 format, unique across all users
- **Name**: 1-100 characters, no whitespace-only strings (trimmed before validation)
- **Password**: Minimum 8 characters (Better Auth enforces during signup)
- **ID**: Generated as UUID v4 by Better Auth (non-sequential to prevent enumeration)

**SQLModel Implementation** (for reference—Better Auth manages this):
```python
from sqlmodel import SQLModel, Field
from datetime import datetime
from typing import Optional
import uuid

class User(SQLModel, table=True):
    __tablename__ = "users"

    id: str = Field(
        default_factory=lambda: str(uuid.uuid4()),
        primary_key=True
    )
    email: str = Field(unique=True, index=True, max_length=254)
    name: str = Field(max_length=100)
    password_hash: str = Field()  # Better Auth manages hashing
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    # Relationship to tasks (one user has many tasks)
    # tasks: List["Task"] = Relationship(back_populates="owner")
```

**Lifecycle**:
1. **Creation**: User signs up via `/api/auth/signup` → Better Auth creates record
2. **Authentication**: User signs in via `/api/auth/signin` → Better Auth verifies password_hash
3. **Updates**: User updates profile (Phase III feature) → `updated_at` timestamp refreshed
4. **Deletion**: Not supported in Phase II (deferred to Phase III)

---

### Task Entity

**Purpose**: Represents a todo item owned by a specific user. Demonstrates user data isolation pattern for all Phase II user-scoped resources.

**Managed By**: Backend application (via SQLModel and Alembic migrations)

**Schema**:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | INTEGER | PRIMARY KEY, AUTO INCREMENT | Task unique identifier |
| `user_id` | TEXT | FOREIGN KEY → users.id, NOT NULL | Owner's user ID |
| `title` | TEXT | NOT NULL | Task title (1-200 characters) |
| `description` | TEXT | NULL | Optional task description (max 1000 characters) |
| `completed` | BOOLEAN | NOT NULL, DEFAULT FALSE | Task completion status |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Task creation timestamp |
| `updated_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last task update timestamp |

**Indexes**:
- Primary key index on `id` (automatic)
- Index on `user_id` (for efficient user-scoped queries)
- Index on `created_at` (for sorting tasks by creation date)

**Foreign Keys**:
- `user_id` → `users.id` with `ON DELETE CASCADE` (if user deleted, their tasks deleted)

**Validation Rules**:
- **Title**: Required, 1-200 characters, no whitespace-only strings
- **Description**: Optional, max 1000 characters, trimmed
- **User_id**: Must exist in users table (foreign key enforces this)
- **Completed**: Boolean (true/false), defaults to false

**SQLModel Implementation**:
```python
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from typing import Optional

class Task(SQLModel, table=True):
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(foreign_key="users.id", index=True)
    title: str = Field(min_length=1, max_length=200)
    description: Optional[str] = Field(default=None, max_length=1000)
    completed: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    # Relationship to user (many tasks belong to one user)
    # owner: Optional[User] = Relationship(back_populates="tasks")
```

**Lifecycle**:
1. **Creation**: User creates task via `POST /api/{user_id}/tasks` → Record inserted with `user_id` from JWT
2. **Read**: User views tasks via `GET /api/{user_id}/tasks` → Query filtered by `WHERE user_id = {authenticated_user}`
3. **Update**: User edits task via `PATCH /api/{user_id}/tasks/{id}` → `updated_at` timestamp refreshed
4. **Toggle**: User completes task via `POST /api/{user_id}/tasks/{id}/complete` → `completed` toggled
5. **Deletion**: User deletes task via `DELETE /api/{user_id}/tasks/{id}` → Record removed

---

## User Isolation Enforcement

**Critical Security Pattern**: All database queries for user-scoped resources MUST filter by authenticated user_id.

### Query Pattern (Correct ✅):
```python
# Extract user_id from JWT token (not from URL!)
authenticated_user = await verify_jwt(token)

# Verify URL user_id matches JWT user_id
if url_user_id != authenticated_user:
    raise HTTPException(403, "Access denied to this resource")

# Query tasks filtered by authenticated user
tasks = await session.exec(
    select(Task).where(Task.user_id == authenticated_user)
).all()
```

### Anti-Pattern (Vulnerable ❌):
```python
# NEVER trust user_id from URL alone!
tasks = await session.exec(
    select(Task).where(Task.user_id == url_user_id)  # ❌ Security vulnerability!
).all()
```

**Why This Matters**: Without JWT validation, User A could access User B's data by changing the URL:
- Vulnerable: `GET /api/user-b-id/tasks` (if we trust URL)
- Secure: Backend verifies JWT user_id matches `user-b-id`, returns 403 if mismatch

---

## Database Migrations

### Initial Migration (Alembic)

**Migration Name**: `0001_create_users_and_tasks_tables`

**Up Migration**:
```sql
-- Better Auth creates users table automatically, but for reference:
CREATE TABLE users (
    id TEXT PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    password_hash TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Application creates tasks table:
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title TEXT NOT NULL CHECK (length(title) >= 1 AND length(title) <= 200),
    description TEXT CHECK (description IS NULL OR length(description) <= 1000),
    completed BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Indexes for performance:
CREATE INDEX idx_tasks_user_id ON tasks(user_id);
CREATE INDEX idx_tasks_created_at ON tasks(created_at);
```

**Down Migration**:
```sql
DROP INDEX IF EXISTS idx_tasks_created_at;
DROP INDEX IF EXISTS idx_tasks_user_id;
DROP TABLE IF EXISTS tasks CASCADE;
-- Note: users table managed by Better Auth, not dropped by application
```

**Generating Migration**:
```bash
# After defining SQLModel models
alembic revision --autogenerate -m "Create users and tasks tables"

# Review generated migration file
# Edit if needed (e.g., add CHECK constraints manually)

# Apply migration
alembic upgrade head
```

---

## Data Integrity Rules

### Referential Integrity

1. **Users → Tasks**: One-to-many relationship enforced via foreign key
   - One user can have many tasks
   - Each task belongs to exactly one user
   - CASCADE delete: If user deleted, their tasks deleted automatically

2. **Email Uniqueness**: Enforced via UNIQUE constraint on `users.email`
   - Prevents duplicate accounts with same email
   - Better Auth handles this during signup

3. **Required Fields**: NOT NULL constraints ensure data completeness
   - Users: id, email, name, password_hash, timestamps
   - Tasks: id, user_id, title, completed, timestamps

### Data Validation (Application Layer)

**Pydantic Schemas** (in addition to database constraints):
```python
from pydantic import BaseModel, EmailStr, constr

class SignupRequest(BaseModel):
    name: constr(min_length=1, max_length=100, strip_whitespace=True)
    email: EmailStr
    password: constr(min_length=8)

class TaskCreate(BaseModel):
    title: constr(min_length=1, max_length=200, strip_whitespace=True)
    description: Optional[constr(max_length=1000)] = None

class TaskUpdate(BaseModel):
    title: Optional[constr(min_length=1, max_length=200)] = None
    description: Optional[constr(max_length=1000)] = None
    completed: Optional[bool] = None
```

**Validation Order**:
1. Frontend validation (immediate user feedback)
2. Pydantic schema validation (FastAPI request parsing)
3. Database constraints (final enforcement)

---

## Performance Considerations

### Indexes Strategy

**Indexed Columns**:
- `users.id` (primary key, automatic)
- `users.email` (unique index, Better Auth creates)
- `tasks.id` (primary key, automatic)
- `tasks.user_id` (foreign key, explicit index for user-scoped queries)
- `tasks.created_at` (explicit index for sorting)

**Query Patterns Optimized**:
- User lookup by email (signin): `WHERE email = ?` → Uses `users.email` unique index
- User's tasks retrieval: `WHERE user_id = ?` → Uses `tasks.user_id` index
- Tasks sorted by creation: `WHERE user_id = ? ORDER BY created_at DESC` → Uses composite index scan

**Index Usage Analysis**:
```sql
-- Check index usage (PostgreSQL)
EXPLAIN ANALYZE
SELECT * FROM tasks WHERE user_id = 'uuid-here' ORDER BY created_at DESC;

-- Expected: "Index Scan using idx_tasks_user_id on tasks"
```

### Scalability Notes

- **Connection Pooling**: SQLModel async engine handles connection pooling automatically
- **Query Limits**: Implement pagination for large task lists (future enhancement)
- **N+1 Queries**: Avoid loading users for each task (use JOIN if needed in future features)
- **Neon Autoscaling**: Database scales automatically with request volume

---

## Testing Data Model

### Test Scenarios

1. **User Creation**: Verify UUID generation, email uniqueness constraint
2. **Task Creation**: Verify foreign key constraint (user_id must exist)
3. **User Isolation**: Verify tasks filtered by user_id (User A cannot see User B's tasks)
4. **Cascade Delete**: Verify tasks deleted when user deleted (Phase III feature)
5. **Validation**: Verify constraints enforced (title length, email format, etc.)

### Sample Data (Development/Testing)

```sql
-- Insert test users
INSERT INTO users (id, email, name, password_hash, created_at, updated_at)
VALUES
    ('user-1-uuid', 'alice@example.com', 'Alice', 'hashed-password-1', NOW(), NOW()),
    ('user-2-uuid', 'bob@example.com', 'Bob', 'hashed-password-2', NOW(), NOW());

-- Insert test tasks (scoped to users)
INSERT INTO tasks (user_id, title, description, completed, created_at, updated_at)
VALUES
    ('user-1-uuid', 'Alice Task 1', 'Alice first task', FALSE, NOW(), NOW()),
    ('user-1-uuid', 'Alice Task 2', NULL, TRUE, NOW(), NOW()),
    ('user-2-uuid', 'Bob Task 1', 'Bob first task', FALSE, NOW(), NOW());

-- Verify isolation: Alice should see 2 tasks, Bob should see 1 task
SELECT * FROM tasks WHERE user_id = 'user-1-uuid';  -- Returns 2 tasks
SELECT * FROM tasks WHERE user_id = 'user-2-uuid';  -- Returns 1 task
```

---

## Summary

**Entities**: 2 (User, Task)
**Relationships**: 1 (User has many Tasks, one-to-many)
**Indexes**: 5 (3 automatic, 2 explicit)
**Foreign Keys**: 1 (tasks.user_id → users.id with CASCADE delete)
**Validation Rules**: 8 (email format, password length, title length, etc.)

**Security**: User isolation enforced via JWT validation + database filtering by user_id

**Next Steps**: Create API contracts (contracts/ directory) defining how frontend interacts with this data model
